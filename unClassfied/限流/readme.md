#限流
阅读《来谈谈限流》（https://github.com/farmerjohngit/myblog/issues/18?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io）有所收获，记录

##限流种类
###1.并发数限流
维护与一个线程安全的当前连接数就行。
这里可以用JDK并发包中的信号量去实现
nginx采用的应该是该方式

###2.QPS限流
- 计数器
grant方法，判断指定时间间隔内，请求数是否超过上限。
计数器与并发数计数本质类似；并发数限流中，一个计数 +1 的生命周期是[收到请求，请求结束]，计数器方法则是所有请求的生命周期为指定的时间间隔interval。
该方法存在临界问题，两个时间间隔等分上下两段,上线为100；[0,100][100,0]的情况是符合限流条件的，但是中间实际，一个时间段有200个请求被接收。

- 滑动窗口
拿一个一定格数的环，去作为滑动窗口，一定时间内，格数越多，精度越高。
init():初始化环的每个格子，初始化环的总数
run()：定期维护这个环；更新当前工作格到下一个，清空当前工作格，过期环内总数里面，当前工作格上一轮的计数。
grant():当前工作格计数加一，环内总数加一，并与上限对比。

- 漏桶算法（as a meter）
grant(): 与上次请求超过1ms，过期指定个数令牌，并设置上次过期时间。判断桶是否满，未满则加1

- 漏桶算法（as a queue）
grant:请求压入队列，队列已经满了，则为否
consume():在执行队列里面的请求
这个地方作者的说法存在疑问，as a queue可以防止突发流量，但是
```
这时1ms内来了100个请求，那只有前10个会被接受，其他的会被拒绝掉。
```
这个应该是似乎是不对的，10个请求会被立刻执行，剩下100个，会进入队列里面等待。被缓慢逐步执行。

- 令牌桶算法
as a meter 的漏桶算法的另外一种写法。as a meter增加已通过请求数，该方法记录剩余令牌数